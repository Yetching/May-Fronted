### 转译器

- JavaScript

  - babel
  - typescript

  将新特性转换成目标环境所支持

  - typescript
  - flow

  编写时添加类型检查，编译时去掉类型信息

  - jsx

  语法糖

  - terser

  编译期间对代码进行优化并转化为目标代码

  - eslint

  编译期间检查代码规范错误并加以更正



- Css

  - scss
  - less
  - stylus
  - postcss（css-next）

  扩展一些能力，使得css的编写变量函数化，同时通过这些转译器转化成原生css

  - postcss（autoprefixer、stylelint、css modules）

  处理兼容性，规范检查，css模块化等功能通过postcss转译完成



- Html

  - pug
  - moustache

  模板引擎便于编写，同时在编译或者运行时进行目标代码的转换

  - postHtml
  - .....

  各种内容转html，如markdown转html
  
  

### 设计模式

- 访问者模式
  - apply
- 观察/订阅者模式
  - vuejs中对于响应式的处理



### 渲染器

- 组件

  - 组件的产出，初期利用pug等模板引擎得到产出是Html字符串

  - vue，react等越来越多的框架，组件的产出是VNode，虚拟dom

  - 组件如何表示

    - 最简单的VNode结构

      ```javascript
      const eleVnode  = {
          tag: 'div',
          data: ...,
          children: [
          	{
          		tag: 'span',
          		data: ...,
          		...
              },
            	...
          ]
      }
      
      function render(vnode, container) {
          ...
      }
      
      render(eleVnode, document.getElementById('app'))
      ```

      

    - 当tag为组件时

      ```javascript
      class Mycomponent {
      	render() {
      		//render函数产出Vnode
      		return {
      			tag: 'div',
      			data: ...
      			....
      		}
      	}
      }
      
      const eleVnode = {
          tag: Mycomponent,
          ...,
      }
      ```

  - 组件的种类

    - 函数式组件

      ```javascript
      function Mycomponent(props) {
      	//eg
      	return h('h1', props.title)
      }
      
      const Vnode = Mycomponent(props)
      ```

    - 有状态的组件

      ```javascript
      class MyComponent {
      	render() {
      		return {
      			tag: 'div',
      			...
      		}
      	}
      }
      
      const Vnode = new MyComponent().render()
      ```



- 设计VNode

  - VNode描述真实DOM

    ```javascript
    const elementVnode = {
        tag: 'div',
        data: {
            style: ...,
            class: ...
        },
        children: [
            {
                tag: 'span',
                data: 'null',
                children: '文本内容'
            },
            {
                tag: 'span',
                data: {
                    style: ...,
                    class: ...,
                    ...
                },
                children: [
                    {},
                    {},
                    ...
                ]
            }
        ]
    }
    ```

  - VNode描述抽象内容

    - Component

      ```javascript
      class MyComponent {
          render() {
              return {
                  tag: 'div',
                  ...
              }
          }
      }
          
      const eleVnode = {
          tag: 'div',
          ...,
          children: {
          	tag: MyComponent,
          	...
          }
      }
      ```

    - Fragment

      把所有td都作为FragmentVnode的子节点，根元素不是一个真实节点

      当渲染器遇到Fragment时只会直接将所有子节点渲染至页面

      ```javascript
      const Fragment = Symbol()
      
      const FragmentVnode = {
          tag: Fragment,
          ...,
          children: [
          	{
          		tag: 'td',
          		...
              },
            	{
                  tag: 'td',
                  ...
              },
            	...
          ]
      }
      ```

    - Portal

      蒙层指定到自定义区域作为父级，将子节点渲染到给定的父级

      vue3中的teleport

      ```javascript
      const Portal = Symbol()
      
      const PortalVnode = {
          tag: Portal,
          data: {
              target: '#app-root'
          }
          children: {
          	tag: 'div',
              data: {
          		class: 'overlay'
              }
          }
      }
      ```

  - VNode的种类

    - 普通标签
      - Html标签
      - SVG标签
    - Fragment
    - Portal
    - Component
      - 有状态组件，即上文用类形成的
        - 普通的有状态组件
        - 需要被KeepAlive的状态组件
        - 已经被KeptAlive的状态组件
      - 函数式组件，无自己的状态
    - 纯文本

  - 在Vnode中加入flags作为其标识

    - vue2对vnode.tag会尝试性做很多处理，而且判断都是在挂载和patch时进行的，因此性能优化低下

    - 在Vnode创建时通过flags标明，可以在挂载和patch阶段避免很多消耗性能的判断

      ```javascript
      //eg
      if(flags & VNodeFlags.ELEMENT) {
          //普通标签
          mountElement()
      }else if(flags & VNodeFlags.COMPONENT) {
          //组件
          mountComponent()
      }else if(...) {
          ...
      }
      ```

    - 位运算在大量工作任务进行时有性能的提升

  - VNode初步设计结果

    ```javascript
    export interface VNode {
        _isVNode: true
        //当VNode被渲染成为真实DOM后，el的值将会指向真实DOM
        el: Element | null
        flags: VNodeFlags
        tag: string | FuntionalComponent | ComponentClass | null
        data: VNodeData | null
        children: VNodeChildren
        childFlags: childrenFlags
    }
    ```

  - 并非所有类型的VNode的children属性都用来存储子VNode，比如组件的子VNode应该作为slots，因此源码中定义slots来存储组件VNode的子VNode

  

- AOT和JIT概念的了解，我所理解的

  - JIT(just in time)即时编译，原生的js，python等解释型语言就属于这种，在执行时进行编译
  - AOT(ahead of time)提前编译，原生的java，c++等语言属于提前编译源代码，执行时的代码已经不是源代码了
  - 前端中JIT的概念，就像直接源代码在浏览器端执行
  - AOT在前端的概念，如vue，react等框架会将组件、模板等非原生特性在构建时即服务端就进行编译为JavaScript
  - AOT构建比JIT性能低，因为时间更慢，框架app比原生要慢不少（不知道这么理解对不对）